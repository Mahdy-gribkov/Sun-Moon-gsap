<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cosmic Moon with Blinking</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #0a0a0a; /* Dark background for moon */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        #scene-container {
            width: 100%;
            height: 100%;
            display: block;
            cursor: move;
        }
        /* Minimal error style */
        .error-display {
             position: absolute; top: 0; left: 0; right: 0; bottom: 0;
             background-color: black; color: red; font-family: monospace;
             font-size: 14px; padding: 20px; white-space: pre-wrap; z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="scene-container"></canvas>

    <script type="module">
        console.log("Script module started... attempting to load modules.");

        // --- Helper function to show errors ---
        const showError = (error, context) => {
            console.error(`A critical error occurred ${context}:`, error);
             try {
                if (typeof animationFrameId !== 'undefined' && animationFrameId) {
                     window.cancelAnimationFrame(animationFrameId);
                }
             } catch (e) {
                 console.error("Error cancelling animation frame:", e);
             }
            document.body.innerHTML = `<div class="error-display">A critical error occurred ${context}:\n\n${error?.stack ?? error ?? 'Unknown error'}</div>`;
        };

        let animationFrameId;

        // --- Loading core modules ---
        Promise.all([
            import('https://esm.sh/three@0.165.0'),
            import('https://esm.sh/gsap@3.12.5')
        ]).then(([THREE, gsapModule]) => {

            console.log("All modules imported successfully. Three.js version:", THREE.REVISION);

            const { gsap } = gsapModule;

            console.log("init() logic starting...");

            // --- GLSL SHADER CODE (Enhanced Moon Theme) ---
            const vertexShader = `
                uniform float u_time;
                uniform float u_intensity;
                varying vec2 vUv;
                varying vec3 vNormal;
                varying float vNoise;

                float fbm_noise(vec3 p, float time) {
                    float total = 0.0;
                    float amplitude = 0.6;
                    float frequency = 2.0;
                    for (int i = 0; i < 5; i++) {
                        total += amplitude * sin(dot(p * frequency, vec3(1.2, 0.8, 0.5)) + time * 0.4);
                        total += amplitude * sin(dot(p * frequency, vec3(-0.7, 0.6, 1.5)) + time * 0.3);
                        total += amplitude * sin(dot(p * frequency, vec3(0.3, -0.9, 0.8)) + time * 0.2);
                        frequency *= 2.0;
                        amplitude *= 0.5;
                    }
                    return total;
                }

                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec3 displacedPosition = position;
                    float noise = fbm_noise(normalize(position), u_time * 0.4);
                    vNoise = noise;
                    displacedPosition += normal * noise * 0.08 * u_intensity; // More dramatic moon surface
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
                }
            `;

            const fragmentShader = `
                varying vec2 vUv;
                varying vec3 vNormal;
                varying float vNoise;
                uniform float u_time;
                uniform float u_pulse;
                uniform vec3 u_baseColor;
                uniform vec3 u_glowColor;
                uniform float u_glowIntensity;

                void main() {
                    vec3 normal = normalize(vNormal);
                    float finalNoise = vNoise * (1.0 + u_pulse * 0.6);
                    vec3 colorA = u_baseColor;
                    vec3 colorB = vec3(0.9, 0.9, 1.0); // Bright cool gray
                    vec3 colorC = vec3(1.0, 1.0, 1.0); // Pure white highlights
                    vec3 colorD = vec3(0.6, 0.6, 0.8); // Darker craters
                    vec3 surfaceColor = mix(colorA, colorB, smoothstep(-0.4, 0.3, finalNoise));
                    surfaceColor = mix(surfaceColor, colorC, smoothstep(0.2, 0.5, finalNoise));
                    surfaceColor = mix(surfaceColor, colorD, smoothstep(-0.6, -0.2, finalNoise));
                    float fresnel = 1.0 - dot(normal, vec3(0.0, 0.0, 1.0));
                    fresnel = pow(fresnel, 2.0 + u_pulse * 1.8);
                    vec3 corona = u_glowColor * fresnel * u_glowIntensity * (1.4 + u_pulse * 0.8);
                    vec3 finalColor = surfaceColor + corona;
                    finalColor += mix(vec3(0.0), u_glowColor, smoothstep(0.2, 0.7, finalNoise)) * u_glowIntensity;
                    finalColor += mix(vec3(0.0), vec3(0.9, 0.95, 1.0), smoothstep(0.3, 0.8, finalNoise)) * 1.2;
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            // --- Global Variables ---
            const canvas = document.getElementById('scene-container');
            let width = canvas.clientWidth;
            let height = canvas.clientHeight;
            const mouse = new THREE.Vector2(0, 0);
            const target = new THREE.Vector2(0, 0);

            // --- Scene Setup ---
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 5;

            const renderer = new THREE.WebGLRenderer({
                antialias: true,
                canvas: canvas,
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x0a0a0a, 1); // Dark background
            renderer.sortObjects = true;
            console.log("...Scene, Camera, Renderer created.");

            // --- Lights (Enhanced Moon lighting) ---
            const ambientLight = new THREE.AmbientLight(0x404080, 1.2); // Much stronger cool blue ambient
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); // Much brighter directional
            directionalLight.position.set(0, 0, 5);
            scene.add(directionalLight);
            // Add a strong blue light for moon glow
            const moonLight = new THREE.PointLight(0x8bb8ff, 1.4, 30); // Stronger and wider
            moonLight.position.set(0, 0, 0);
            scene.add(moonLight);
            // Add a secondary cool light
            const coolLight = new THREE.PointLight(0x6bb6ff, 0.8, 35); // Stronger secondary
            coolLight.position.set(2, 2, 2);
            scene.add(coolLight);
            // Add a third accent light for depth
            const accentLight = new THREE.PointLight(0xadd8e6, 0.6, 20);
            accentLight.position.set(-3, -1, 1);
            scene.add(accentLight);

            // --- Groups ---
            const moonBodyGroup = new THREE.Group();
            scene.add(moonBodyGroup);

            const faceGroup = new THREE.Group();
            faceGroup.position.z = 1.78;
            faceGroup.renderOrder = 999;
            moonBodyGroup.add(faceGroup);

            const orbitGroup = new THREE.Group();
            scene.add(orbitGroup);
            console.log("...Lights and Groups created.");

            // --- Moon Mesh ---
            const moonGeometry = new THREE.SphereGeometry(2, 128, 128);
            const shaderMaterial = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    u_time: { value: 0 },
                    u_pulse: { value: 0 },
                    u_intensity: { value: 1.2 }, // Higher base intensity
                    u_baseColor: { value: new THREE.Color(0x999999) }, // Brighter gray moon base
                    u_glowColor: { value: new THREE.Color(0x9bb9ff) }, // Brighter blue moon glow
                    u_glowIntensity: { value: 1.8 } // New uniform for enhanced glow
                },
            });
            const moonMesh = new THREE.Mesh(moonGeometry, shaderMaterial);
            moonMesh.renderOrder = 1;
            moonBodyGroup.add(moonMesh);

            // --- Moon Halo (Enhanced) ---
            const haloGeometry = new THREE.SphereGeometry(2.1, 32, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({
                color: 0x8bb8ff, transparent: true, opacity: 0.25, // Stronger blue moon glow
                blending: THREE.AdditiveBlending, side: THREE.BackSide,
                depthWrite: false
            });
            const haloMesh = new THREE.Mesh(haloGeometry, haloMaterial);
            haloMesh.renderOrder = 2;
            moonBodyGroup.add(haloMesh);
            
            // Add outer halo
            const outerHaloGeometry = new THREE.SphereGeometry(2.3, 32, 32);
            const outerHaloMaterial = new THREE.MeshBasicMaterial({
                color: 0x6bb6ff, transparent: true, opacity: 0.15,
                blending: THREE.AdditiveBlending, side: THREE.BackSide,
                depthWrite: false
            });
            const outerHaloMesh = new THREE.Mesh(outerHaloGeometry, outerHaloMaterial);
            outerHaloMesh.renderOrder = 1;
            moonBodyGroup.add(outerHaloMesh);
            console.log("...Moon Mesh, Shader, and Halo created.");

            // --- Stars (Enhanced) ---
            const starGroup = new THREE.Group();
            moonBodyGroup.add(starGroup);
            const starGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const starMaterials = [
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 }),
                new THREE.MeshBasicMaterial({ color: 0x8bb8ff, transparent: true, opacity: 0.8 }),
                new THREE.MeshBasicMaterial({ color: 0x6bb6ff, transparent: true, opacity: 0.7 })
            ];
            for (let i = 0; i < 120; i++) { // More stars for richer starfield
                const star = new THREE.Mesh(starGeometry, starMaterials[Math.floor(Math.random() * starMaterials.length)]);
                const angle = Math.random() * Math.PI * 2;
                const radius = 2.3 + Math.random() * 1.5;
                star.position.set(
                    Math.cos(angle) * radius, 
                    Math.sin(angle) * radius, 
                    (Math.random() - 0.5) * 2
                );
                star.userData.twinkleSpeed = 0.8 + Math.random() * 1.5;
                star.userData.baseScale = 0.5 + Math.random() * 1.0;
                star.scale.setScalar(star.userData.baseScale);
                starGroup.add(star);
            }
            console.log("...Stars created.");

            // --- Asteroids (Enhanced Moon theme) ---
            const asteroidGeometry = new THREE.IcosahedronGeometry(0.08, 1); // Larger and more detailed
            const asteroidMaterials = [
                new THREE.MeshPhongMaterial({ color: 0x5a5a5a, flatShading: true, shininess: 15 }), // Brighter gray
                new THREE.MeshPhongMaterial({ color: 0x4a4a4a, flatShading: true, shininess: 20 }), // Medium gray
                new THREE.MeshPhongMaterial({ color: 0x3a3a3a, flatShading: true, shininess: 25 }), // Dark gray
                new THREE.MeshPhongMaterial({ color: 0x4a4a5a, flatShading: true, shininess: 18 }), // Blue-gray
                new THREE.MeshPhongMaterial({ color: 0x5a5a6a, flatShading: true, shininess: 22 })  // Light blue-gray
            ];
            const numAsteroids = 30; // More asteroids for richer scene
            const orbitRadius = 8;
            const asteroids = [];
            
            for (let i = 0; i < numAsteroids; i++) {
                const particle = new THREE.Mesh(asteroidGeometry, asteroidMaterials[Math.floor(Math.random() * asteroidMaterials.length)]);
                const angle = Math.random() * Math.PI * 2;
                const radius = orbitRadius + (Math.random() - 0.5) * 4;
                const yPos = (Math.random() - 0.5) * 3;
                particle.position.set(Math.cos(angle) * radius, yPos, Math.sin(angle) * radius);
                particle.userData.orbitId = Math.random() * 100;
                particle.userData.orbitSpeed = 0.003 + Math.random() * 0.003; // Slower for moon
                particle.userData.rotationAxis = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
                particle.userData.rotationSpeed = Math.random() * 0.01;
                asteroids.push(particle);
                orbitGroup.add(particle);
            }
            console.log("...Asteroids created.");

            // --- Eyes (Moon theme) ---
            const eyeballGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const eyeballMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xf0f0f0, // Slightly off-white for moon
                shininess: 60, 
                emissive: 0x020202 
            });
            const pupilGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const pupilMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                depthTest: false,
                depthWrite: false,
                transparent: true,
                opacity: 1.0
            });

            // Left Eye Setup
            const eyeLeft = new THREE.Group();
            const eyeballLeft = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
            const pupilLeft = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupilLeft.position.z = 0.301;
            pupilLeft.renderOrder = 1;
            eyeballLeft.renderOrder = 0;
            eyeLeft.add(eyeballLeft, pupilLeft);
            eyeLeft.position.x = -0.7;
            faceGroup.add(eyeLeft);

            // Right Eye Setup
            const eyeRight = new THREE.Group();
            const eyeballRight = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
            const pupilRight = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupilRight.position.z = 0.301;
            pupilRight.renderOrder = 1;
            eyeballRight.renderOrder = 0;
            eyeRight.add(eyeballRight, pupilRight);
            eyeRight.position.x = 0.7;
            faceGroup.add(eyeRight);

            // --- Eyebrows (Moon theme) ---
            const eyebrowGeometry = new THREE.SphereGeometry(0.3, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.25);
            const eyebrowMaterial = new THREE.MeshPhongMaterial({
                color: 0x666666, // Dark gray for moon eyebrows
                shininess: 60,
                emissive: 0x010101,
                side: THREE.FrontSide
            });

            // Left Eyebrow
            const eyebrowLeft = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            eyebrowLeft.position.set(-0.7, 0.15, 0.32);
            eyebrowLeft.renderOrder = 3;
            faceGroup.add(eyebrowLeft);

            // Right Eyebrow
            const eyebrowRight = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            eyebrowRight.position.set(0.7, 0.15, 0.32);
            eyebrowRight.renderOrder = 3;
            faceGroup.add(eyebrowRight);

            console.log("...Eyes and eyebrows created.");

            // --- Mouth (Moon theme) ---
            const mouthShape = new THREE.Shape();
            mouthShape.moveTo(-0.5, -0.1);
            mouthShape.bezierCurveTo(-0.25, -0.3, 0.25, -0.3, 0.5, -0.1);
            mouthShape.bezierCurveTo(0.25, -0.25, -0.25, -0.25, -0.5, -0.1);
            const mouthGeometry = new THREE.ShapeGeometry(mouthShape);
            const mouthMaterial = new THREE.MeshPhongMaterial({
                color: 0x444444, // Dark gray for moon mouth
                shininess: 40, 
                side: THREE.DoubleSide
             });
            const mouthMesh = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouthMesh.position.set(0, -0.6, 0.35);
            mouthMesh.scale.set(1.0, 1.0, 1.0);
            mouthMesh.renderOrder = 1;
            faceGroup.add(mouthMesh);
            console.log("...Face created.");

            // --- Event Listeners ---
            const handleMouseMove = (event) => {
                mouse.x = (event.clientX / width) * 2 - 1;
                mouse.y = -(event.clientY / height) * 2 + 1;
            };
            const handleResize = () => {
                width = canvas.clientWidth;
                height = canvas.clientHeight;
                if (height === 0) return;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            };
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('resize', handleResize);
            // Add click to trigger blink for testing
            window.addEventListener('click', () => {
                console.log("Manual blink triggered!");
                blink();
            });
            console.log("...Event Listeners added.");

            // --- Animation Loop ---
            const clock = new THREE.Clock();
            const targetLookAt = new THREE.Vector3();
            const eyeTarget = new THREE.Vector3();

            console.log("...Starting GSAP animations setup.");
            gsap.to(shaderMaterial.uniforms.u_pulse, {
                value: 1.0, duration: 2.5, yoyo: true, repeat: -1, ease: "sine.inOut",
                onUpdate: () => {
                    haloMesh.material.opacity = 0.25 + shaderMaterial.uniforms.u_pulse.value * 0.15;
                    haloMesh.scale.setScalar(1 + shaderMaterial.uniforms.u_pulse.value * 0.08);
                    outerHaloMesh.material.opacity = 0.15 + shaderMaterial.uniforms.u_pulse.value * 0.1;
                    outerHaloMesh.scale.setScalar(1 + shaderMaterial.uniforms.u_pulse.value * 0.05);
                }
            });
            gsap.to(shaderMaterial.uniforms.u_intensity, {
                value: 0.6, duration: 2.8, yoyo: true, repeat: -1, ease: "sine.inOut" // Even stronger
            });
            gsap.to(shaderMaterial.uniforms.u_glowIntensity, {
                value: 2.5, duration: 3.2, yoyo: true, repeat: -1, ease: "sine.inOut" // Animate glow intensity
            });
            console.log("...GSAP animations started.");

            // --- Blinking Logic ---
            setTimeout(() => {
                console.log("Test blink starting...");
                blink();
            }, 2000);
            let lastBlinkTime = 0;
            const blinkInterval = 4 + Math.random() * 3; // 4-7 seconds between blinks (slower for moon)
            let isBlinking = false;

            const blink = () => {
                if (isBlinking) return;
                isBlinking = true;
                console.log("Blinking! Pupils should shrink...");

                const leftPupil = eyeLeft.children[1];
                const rightPupil = eyeRight.children[1];
                
                console.log("Left pupil:", leftPupil);
                console.log("Right pupil:", rightPupil);

                gsap.to(leftPupil.scale, {
                    x: 0.1, y: 0.1, z: 0.1,
                    duration: 0.08,
                    ease: "power2.in",
                });
                gsap.to(rightPupil.scale, {
                    x: 0.1, y: 0.1, z: 0.1,
                    duration: 0.08,
                    ease: "power2.in",
                    onComplete: () => {
                        console.log("Pupils should be tiny now");
                        gsap.to(leftPupil.scale, {
                            x: 1, y: 1, z: 1,
                            duration: 0.1,
                            ease: "power2.out",
                        });
                        gsap.to(rightPupil.scale, {
                            x: 1, y: 1, z: 1,
                            duration: 0.1,
                            ease: "power2.out",
                            onComplete: () => {
                                isBlinking = false;
                                console.log("Blink complete - pupils should be back to normal size");
                            }
                        });
                    }
                });
            };

            const animate = () => {
                try {
                    animationFrameId = window.requestAnimationFrame(animate);

                    const elapsedTime = clock.getElapsedTime();
                    shaderMaterial.uniforms.u_time.value = elapsedTime;

                    // Blinking logic
                    if (elapsedTime - lastBlinkTime > blinkInterval) {
                        console.log(`Time to blink! elapsed: ${elapsedTime}, lastBlink: ${lastBlinkTime}, interval: ${blinkInterval}`);
                        blink();
                        lastBlinkTime = elapsedTime;
                    }

                    target.x += (mouse.x - target.x) * 0.08; // Slower movement for moon
                    target.y += (mouse.y - target.y) * 0.08;

                    gsap.to(moonBodyGroup.position, {
                        x: target.x * 0.4, y: target.y * 0.4, // Gentler movement
                        duration: 2.5, ease: 'power2.out',
                    });

                    // Eye Following
                    faceGroup.getWorldPosition(eyeTarget);
                    eyeTarget.add(new THREE.Vector3(mouse.x * 1.5, mouse.y * 1.5, 3.0)); // Gentler eye following
                    if (eyeLeft.getWorldPosition(new THREE.Vector3()).distanceToSquared(eyeTarget) > 0.001) {
                         eyeLeft.lookAt(eyeTarget);
                    }
                     if (eyeRight.getWorldPosition(new THREE.Vector3()).distanceToSquared(eyeTarget) > 0.001) {
                        eyeRight.lookAt(eyeTarget);
                    }

                    // Mouth animation (gentler for moon)
                    const happyFactor = Math.max(0, mouse.y);
                    const smileScale = 0.9 + happyFactor * 0.1; // More subtle
                    gsap.to(mouthMesh.scale, { y: smileScale, x: smileScale, duration: 0.6 });
                    gsap.to(mouthMesh.position, { y: -0.6 - happyFactor * 0.03, duration: 0.6 }); // More subtle

                    // Enhanced star twinkling
                    starGroup.children.forEach((star) => {
                        const twinkle = 0.4 + Math.sin(elapsedTime * star.userData.twinkleSpeed) * 0.4;
                        const scale = star.userData.baseScale + Math.sin(elapsedTime * star.userData.twinkleSpeed * 1.5) * 0.3;
                        star.material.opacity = twinkle;
                        star.scale.setScalar(scale);
                    });

                    // Update asteroids
                    asteroids.forEach(asteroid => {
                        asteroid.position.x = Math.cos(elapsedTime * asteroid.userData.orbitSpeed + asteroid.userData.orbitId) * (orbitRadius + Math.sin(asteroid.userData.orbitId) * 2);
                        asteroid.position.z = Math.sin(elapsedTime * asteroid.userData.orbitSpeed + asteroid.userData.orbitId) * (orbitRadius + Math.sin(asteroid.userData.orbitId) * 2);
                        asteroid.rotateOnAxis(asteroid.userData.rotationAxis, asteroid.userData.rotationSpeed);
                    });

                    renderer.render(scene, camera);

                } catch(error) {
                    showError(error, 'during animation loop');
                }
            };

            // Start the animation
            console.log("...Calling animate() for the first time.");
            animate();

        }).catch(error => {
            showError(error, 'during module import');
        });

    </script>
</body>
</html>
